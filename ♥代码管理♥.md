# åŠ é¡¿å·

```
  orderInfo?.orderNoAndCodeList.map((item: any, index: number) => (
                     <span key={item.name}>
                     <NavLink to={`/trading/order/detail?code=${item.value}`}>
                      {item.name}
                     </NavLink>
                     {index < orderInfo?.orderNoAndCodeList.length - 1 && 'ã€'}
                                </span>
                            ))
```

# filterNum filterTaxRate é‡‘é¢.00 ç™¾åˆ†æ¯”

```
const filterNum = (price: number | string) => {
    if (!price && typeof price !== 'number') return ''
    return Number(price).toFixed(2)
}
const filterTaxRate = (taxrate: number | string) => {
    if (!taxrate && typeof taxrate !== 'number') return ''
    return Number(taxrate) * 100
}

export { filterNum, filterTaxRate }
```

# æ—¶é—´æˆ³ dayjs

```
import dayjs from 'dayjs';

// è·å–å½“å‰æ—¶é—´çš„æ—¶é—´æˆ³   ç²¾ç¡®åˆ°æ¯«ç§’  ç²¾ç¡®åˆ°ç§’æ˜¯unix()
const currentTimestamp = dayjs().valueOf();  

// è·å–å½“å¤©çš„å¼€å§‹æ—¶é—´å’Œç»“æŸæ—¶é—´çš„æ—¶é—´æˆ³
const todayStartTimestamp = dayjs().startOf('day').valueOf();
const todayEndTimestamp = dayjs().endOf('day').valueOf();

// è®¡ç®—å½“å‰æ—¶é—´æˆ³ç›¸å¯¹äºå½“å¤©æ—¶é—´æˆ³çš„ç™¾åˆ†æ¯”
const percentage = ((currentTimestamp - todayStartTimestamp) / (todayEndTimestamp - todayStartTimestamp)) * 100;

console.log(`å½“å‰æ—¶é—´æˆ³å å½“å¤©æ—¶é—´æˆ³çš„ç™¾åˆ†æ¯”ï¼š${percentage.toFixed(2)}%`);


 /**  å¤„ç†ä¿å­˜çš„æ•°æ®  */
    /**  æ—¶é—´å¤„ç† ç²¾ç¡®åˆ°ç§’ */
 const dateFields = ['applyEndTime', ]
        dateFields.forEach(field => {
            params[field] = values[field] ? dayjs(values[field]).unix() * 1000 : undefined
        })
  /**  æ—¶é—´å¤„ç† ç²¾ç¡®åˆ°æ¯«ç§’ */
 const dateFields_activity = ['activityEnd', 'activityStart']
 dateFields_activity.forEach(field => {
    params[field] = values[field] ? dayjs(values[field]).valueOf() : undefined
     })

å›æ˜¾
 /**  å°é¢  */
        data.cover = data.cover
            ? [
                  {
                      uid: '-1',
                      name: 'image.png',
                      status: 'done',
                      url: data.cover,
                  },
              ]
            : []

 /**  æ—¶é—´å¤„ç†  */
        const dateFields = [   'activityEnd', ]
        dateFields.forEach(field => {
            data[field] = data[field] ? dayjs(data[field]) : undefined
        })





















```

# textarea åŠ è¾¹æ¡†

```
 textarea {
            border: 1px solid #d9d9d9;
            border-radius: 6px;
        }
        textarea.ant-input:hover,
        textarea:focus {
            border: 1px solid #1890ff;
            border-radius: 6px;
            -webkit-box-shadow: none;
            box-shadow: none;
        }
```

# å¤åˆ¶é“¾æ¥ å›¾ç‰‡ ä¸‹è½½æµ·æŠ¥

```
import copy from 'copy-to-clipboard'
   <svg
                                className={classnames('icon', styles.icon)}
                                aria-hidden="true"
                                style={{ fill: '#1678FF', marginLeft: 8 }}
                                onClick={() => {
                                    copy(email)
                                    Toast.show('å¤åˆ¶æˆåŠŸ')
                                }}
                            >
                                <use xlinkHref="#fuzhi" />
                            </svg>
```

```
import Clipboard from 'clipboard'

// data-clipboard-text={xxx}


/**
     *  å¤åˆ¶æŠ¥åé“¾æ¥
     */
    const copy = new Clipboard('.copy-btn')
    copy.on('success', function (e) {
        message.success('å¤åˆ¶é“¾æ¥æˆåŠŸ')
        e.clearSelection()
    })
    copy.on('error', function (e) {
        message.error('å¤åˆ¶å¤±è´¥')
        console.error('Action:', e.action)
        console.error('Trigger:', e.trigger)
    })

    /**
     *  é”€æ¯å®ä¾‹
     *  */
    useEffect(() => {
        return () => {
            copy.destroy()
        }
    }, [copy])

                    <div className={styles.link}>
                        <span className={styles.enroll_link} id="copy_content">
                            {`${getEnrollMobilePath()}&applyChannel=${
                                ENROLL_CHANNEL_ENUM[ENROLL_CHANNEL.LINK]
                            }`}
                        </span>
                        <Button
                            data-clipboard-target="#copy_content"
                            type="primary"
                            className={'copy-btn'}
                        >
                            å¤åˆ¶
                        </Button>
                    </div>
```

```
  /**
     * ä¼˜åŒ–åçš„å¤åˆ¶äºŒç»´ç å›¾ç‰‡   //æ³¨:æ­¤æ–¹æ³•åªèƒ½åœ¨localhostè·Ÿhttpsåè®®ä¸‹å¯ç”¨,httpåè®®ä¸‹ä¸å­˜åœ¨æ­¤æ–¹æ³•
     * å°†base64è½¬æˆblobæ ¼å¼
     * @returns {*}
     */
    const base64ToBlob = (urlData: any, _type: any) => {
        const arr = urlData.split(',')
        const mime = arr[0].match(/:(.*?);/)[1] || _type
        // å»æ‰urlçš„å¤´ï¼Œå¹¶è½¬åŒ–ä¸ºbyte
        const bytes = window.atob(arr[1])
        // å¤„ç†å¼‚å¸¸,å°†asciiç å°äº0çš„è½¬æ¢ä¸ºå¤§äº0
        const ab = new ArrayBuffer(bytes.length)
        // ç”Ÿæˆè§†å›¾ï¼ˆç›´æ¥é’ˆå¯¹å†…å­˜ï¼‰ï¼š8ä½æ— ç¬¦å·æ•´æ•°ï¼Œé•¿åº¦1ä¸ªå­—èŠ‚
        const ia = new Uint8Array(ab)
        for (let i = 0; i < bytes.length; i++) {
            ia[i] = bytes.charCodeAt(i)
        }
        return new Blob([ab], {
            type: mime,
        })
    }

    /**
     * å¤åˆ¶äºŒç»´ç å›¾ç‰‡\
     */
    const clickCopyImgCode = async () => {
        // å°† qrcode ç”Ÿæˆçš„äºŒç»´ç åˆ©ç”¨canvasè‡ªå¸¦çš„ toDataURL è½¬æˆbase64 æ ¼å¼ ç„¶åå†è½¬æˆ Blobæ ¼å¼ ä½¿ç”¨ clipboard.write å¤åˆ¶
        const canvasImg: any = document.getElementById('QR-code') // è·å–canvasç±»å‹çš„äºŒç»´ç 
        const file = canvasImg?.toDataURL('image/jpg')
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const type = 'image/png'
        const conversions = base64ToBlob(file, type)
        try {
            await navigator.clipboard.write([
                // eslint-disable-next-line no-undef
                new ClipboardItem({
                    [conversions.type]: conversions,
                }),
            ])
            message.success('å¤åˆ¶äºŒç»´ç æˆåŠŸ')
        } catch (error) {
            message.error('è¯·åœ¨httpsåè®®ä¸‹æ“ä½œ')
        }
    }








                    <div className={styles.qrcode}>
                        <QRCode
                            id="QR-code"
                            value={`${getEnrollMobilePath()}&applyChannel=${
                                ENROLL_CHANNEL_ENUM[ENROLL_CHANNEL.QRCODE]
                            }`}
                            size={112}
                            fgColor="#000000"
                            className={styles.qrcode_img}
                        />
                        <Button type="primary" onClick={() => clickCopyImgCode()}>
                            å¤åˆ¶
                        </Button>
                    </div>
```

```
import html2canvas from 'html2canvas'

/**
     * ä¸‹è½½æµ·æŠ¥
     */
    const downloadScreenshot = () => {
        const element = document.querySelector('#div_to_capture')

        // è·å–æ‰€æœ‰çš„å›¾ç‰‡å…ƒç´ 
        const images = element.querySelectorAll('img')
        let loadedCount = 0

        // ç›‘å¬å›¾ç‰‡åŠ è½½å®Œæˆäº‹ä»¶
        images.forEach(image => {
            if (image.complete) {
                // å›¾ç‰‡å·²ç»åŠ è½½å®Œæˆ
                handleImageLoad()
            } else {
                // å›¾ç‰‡æœªåŠ è½½å®Œæˆï¼Œç»‘å®šloadäº‹ä»¶ç›‘å¬
                image.addEventListener('load', handleImageLoad)
            }
        })

        function handleImageLoad() {
            loadedCount++

            if (loadedCount === images.length) {
                // ä½¿ç”¨ HTML2Canvas åˆ›å»ºç”»å¸ƒå¹¶æˆªå– div
                html2canvas(element, {
                    useCORS: true,
                    scrollY: 0,
                    scrollX: 0,
                    backgroundColor: null,
                    logging: false,
                }).then(canvas => {
                    // å°†ç”»å¸ƒè½¬åŒ–ä¸ºå›¾åƒ URL
                    const imgURL = canvas.toDataURL()
                    // åˆ›å»ºä¸€ä¸ª a æ ‡ç­¾ç”¨äºä¸‹è½½å›¾ç‰‡
                    const link = document.createElement('a')
                    link.href = imgURL
                    link.download = 'æŠ¥åæµ·æŠ¥.png'

                    // å°†æ ‡ç­¾æ·»åŠ åˆ°é¡µé¢
                    document.body.appendChild(link)

                    link.click()
                    document.body.removeChild(link)
                })
            }
        }
    }




<div className={styles.poster_div}>
                        <div className={styles.poster} id="div_to_capture">
                            {Number(type) === Number(TYPE_ENUM.ORG) ? orgPoster() : planPoster()}
                        </div>
                        <Button onClick={downloadScreenshot} icon={<DownloadOutlined />}>
                            ä¸‹è½½
                        </Button>
                    </div>
```

```
  const posterRef = useRef<HTMLDivElement>(null)
  <div className={styles.poster_wrapper} ref={posterRef}></div>

    /**  ç‚¹å‡»ä¿å­˜æµ·æŠ¥  */
    const onSavePoster = () => {
        if (posterRef) {
            html2canvas(posterRef.current!, {
                useCORS: true,
                scrollY: 0,
                scrollX: 0,
                backgroundColor: null,
            }).then(canvas => {
                // å°†ç”»å¸ƒè½¬åŒ–ä¸ºå›¾åƒ URL
                const imgURL = canvas.toDataURL()
                // åˆ›å»ºä¸€ä¸ª a æ ‡ç­¾ç”¨äºä¸‹è½½å›¾ç‰‡
                const linkDOM = document.createElement('a')
                linkDOM.href = imgURL
                linkDOM.download = 'ç»ƒä¹ æµ·æŠ¥.png'

                // å°†æ ‡ç­¾æ·»åŠ åˆ°é¡µé¢
                document.body.appendChild(linkDOM)

                linkDOM.click()
                document.body.removeChild(linkDOM)
            })
        }
    }
```

```
    const onSaveImg = () => {
        handler.current = Toast.show({
            icon: 'loading',
        })
        html2canvas(canvasRef.current!, {
            useCORS: true,
            scrollY: 0,
            scrollX: 0,
            allowTaint: true,
            imageTimeout:30000,
        
            backgroundColor: null,
        })
            .then(canvas => {
                // å°†ç”»å¸ƒè½¬åŒ–ä¸ºå›¾åƒ URL
                const imgURL = canvas.toDataURL()
                // åˆ›å»ºä¸€ä¸ª a æ ‡ç­¾ç”¨äºä¸‹è½½å›¾ç‰‡
                const link = document.createElement('a')
                link.href = imgURL
                link.download = 'æŠ¥åæµ·æŠ¥.png'
                // å°†æ ‡ç­¾æ·»åŠ åˆ°é¡µé¢
                document.body.appendChild(link)
                link.click()
                document.body.removeChild(link)
                // å…³é—­loading toast
                handler.current?.close()
                Toast.show({
                    icon: 'success',
                    content: 'ä¿å­˜æˆåŠŸ',
                })
            })
            .catch(() => {
                Toast.show({
                    icon: 'fail',
                    content: 'ä¿å­˜å¤±è´¥',
                })
            })
    }
```

# æ»šåŠ¨æ¡ scrollbar

```
  .prevBox::-webkit-scrollbar {
        width: 6px;
        height: 6px;
    }
    .prevBox::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.06);
        border-radius: 3px;
        -webkit-box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.08);
    }
    .prevBox::-webkit-scrollbar-thumb {
        background: rgba(0, 0, 0, 0.12);
        border-radius: 3px;
        -webkit-box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2);
    }
```

# æ¨¡ç³Šæœç´¢é«˜äº®æ˜¾ç¤º

```
    //å¼€ç¥¨ç±»åˆ«  1è“è‰² 2çº¢è‰²  æ¨¡ç³Šæœç´¢é«˜äº®æ˜¾ç¤º
    const showColor = (type: number, light: string) => {
        if (!search) {
            switch (type) {
                case 1:
                    return <span style={{ color: '#1890ff' }}>{light}</span>
                case 2:
                    return <span style={{ color: '#ec808d' }}>{light}</span>
                default:
                    return <span>{'-'}</span>
            }
        }
        const reg = new RegExp(search, 'ig')
        const splitIconTypes = light.split(reg)
        const matchIconTypes = light.match(reg) as string[]

        const res = splitIconTypes.toString().split('-')

        if (search.length !== light.length) {
            return (
                <React.Fragment>
                    {matchIconTypes &&
                        matchIconTypes.map((_, index) => {
                            return (
                                <React.Fragment key={index}>
                                    <span style={{ color: type === 2 ? '#ec808d' : '' }}>
                                        {splitIconTypes[index]}
                                    </span>
                                    <span style={{ color: 'orange' }}>{matchIconTypes[index]}</span>
                                </React.Fragment>
                            )
                        })}
                    <span style={{ color: type === 2 ? '#ec808d' : '' }}>
                        {splitIconTypes[splitIconTypes.length - 1] || ''}
                    </span>
                </React.Fragment>
            )
        } else {
            return (
                <React.Fragment>
                    {matchIconTypes &&
                        matchIconTypes.map((_, index) => {
                            return (
                                <React.Fragment key={index}>
                                    <span style={{ color: type === 2 ? '#ec808d' : '' }}>
                                        {splitIconTypes[index]}
                                    </span>
                                    <span style={{ color: 'orange' }}>{matchIconTypes[index]}</span>
                                </React.Fragment>
                            )
                        })}
                    {res.map((item, index) => {
                        if (search.includes(item) && index === 1) {
                            return (
                                <React.Fragment key={index}>
                                    <span style={{ color: type === 2 ? '#ec808d' : '' }}>
                                        {res[index - 1]}
                                        {'-'}
                                    </span>
                                    <span style={{ color: 'orange' }}>{res[index]}</span>
                                </React.Fragment>
                            )
                        } else if (search.includes(item) && index === 0) {
                            return (
                                <React.Fragment key={index}>
                                    <span style={{ color: 'orange' }}>{res[index]}</span>
                                    <span style={{ color: type === 2 ? '#ec808d' : '' }}>
                                        {'-'}
                                        {res[index + 1]}
                                    </span>
                                </React.Fragment>
                            )
                        }
                    })}
                </React.Fragment>
            )
        }
    }

    // switch (type) {
    //     case 1:
    //         return <span dangerouslySetInnerHTML={{ __html: invoiceNo }}></span>
    //     case 2:
    //         return (
    //             <span
    //                 dangerouslySetInnerHTML={{ __html: invoiceNo }}
    //                 style={{ color: '#ec808d' }}
    //             ></span>
    //         )
    // }
    // }
```

# è´¦å·å’Œeslint

```
/* stylelint-disable selector-class-pattern */

rm -rf node_modules/
```

# è½¬æ ‘çŠ¶è§£æ„ tree æ ‘è½¬list

```
let arr: any[] = []

            const itemMap = new Map()

            for (const item of res) {
                item.children = []
                itemMap.set(item.key, item)
            }

            for (const item of res) {
                const parentKey = item.pid
                if (parentKey !== 0) {
                    const parentItem = itemMap.get(parentKey)
                    if (parentItem) {
                        parentItem.children.push(item)
                    } else {
                        arr.push(item)
                    }
                } else {
                    arr.push(item)
                }
            }

console.log(arr)



function tree2list(tree) {
  const list = []
  const queue = [...tree]
  while(queue.length) {
    const node = queue.shift()
    const children = node.children
    if(children) {
        queue.push(...children)
    }
    list.push(node)
  }
  return list
}





```

# mobx å…±ç”¨ä¸€ä¸ªstore

![](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/meonaXkkAQzVlXxj/img/1bfba03b-0442-4104-a929-8cc9062bbba3.png)

```
import { makeAutoObservable } from 'mobx'

let instance: Store

export class Store {
   
}

export default new Proxy(Store, {
    construct(target) {
        if (!instance) {
            instance = new target()
        }
        return instance
    },
})

 const store = useLocalObservable(() => new Store())
```

# urlå‚æ•°æ”¹å˜

```
   const onUrlChange = (key: string, value: string | number) => {
        let url = new URL(location.href)
        if (url.searchParams.has(key)) {
            url.searchParams.delete(key)
        }
        url.searchParams.append(key, value)
          //å®ç°æ— åˆ·æ–°ä¿®æ”¹url
        window.history.replaceState({}, '', url)

        let jumpUrl =  url.toString()
     
    }
```

# td td è¡¨æ ¼

```
import styles from './index.module.less'
import type AccountingListStore from '../../store'
import type { ReceiveStatisticItemDto } from '@/@types/finance'

/**  åº”æ”¶è´¦æ¬¾è´¦é¾„åˆ†æ  */
const AccountsReceivable = ({ store }: { store: AccountingListStore }) => {
    const { statisticalData = {} } = store || {}
    const { totalMoney = '-', list = [] } = (statisticalData as any) || {}

    const renderTableCells = (
        data: ReceiveStatisticItemDto[],
        accessor: keyof ReceiveStatisticItemDto,
        flag: string,
    ) => {
        return data.map((item: ReceiveStatisticItemDto, index: number) => {
            const value = Number(item[accessor])

            if (isNaN(value)) {
                return <td key={index}>{'-'}</td>
            }

            const formattedValue = accessor === 'money' ? `${flag}${value}` : `${value}${flag}`

            return <td key={index}>{formattedValue}</td>
            // if (Number(item[accessor])) {
            //     if (accessor === 'money') {
            //         return <td key={index}>{`${flag}${Number(item[accessor])}`}</td>
            //     } else {
            //         return <td key={index}>{`${Number(item[accessor])}${flag}`}</td>
            //     }
            // } else {
            //     return <td key={index}>{'-'}</td>
            // }
        })
    }

    return (
        <table className={styles.table}>
            <tr>
                <th>é€¾æœŸç»Ÿè®¡</th>
                {/* {list && renderTableCells(list, 'title')} */}
                <th>3ä¸ªæœˆä»¥å†…</th>
                <th>3~6ä¸ªæœˆ</th>
                <th>6~9ä¸ªæœˆ</th>
                <th>9~12ä¸ªæœˆ</th>
                <th>12~18ä¸ªæœˆ</th>
                <th>18ä¸ªæœˆåŠä»¥ä¸Š</th>
            </tr>
            <tr>
                <th rowSpan={3}>
                    é€¾æœŸæ€»é‡‘é¢: Â¥ <span className={styles.totalMoney}>{totalMoney}</span>{' '}
                </th>
                {list && renderTableCells(list, 'money', 'Â¥')}
            </tr>
            <tr>{list && renderTableCells(list, 'percent', '%')}</tr>
        </table>
    )
}

export default AccountsReceivable
```

# react-dnd æ‹–æ‹½

```
import GlobalContent from '@/components/GlobalContent'
import styles from './index.module.less'
import { useCallback, useEffect, useRef, useState } from 'react'
import { useDrag, useDrop } from 'react-dnd'
import { DndProvider } from 'react-dnd'
import { HTML5Backend } from 'react-dnd-html5-backend'
import SVGIcon from '@/components/SVGIcon'
export const ItemTypes = {
    BOX: 'box',
}

const Box = ({ id, text, index, moveBox }: any) => {
    const ref = useRef(null)

    const [, drop] = useDrop({
        accept: ItemTypes.BOX,
        collect(monitor) {
            return {
                handlerId: monitor.getHandlerId(),
            }
        },
        hover(item, monitor) {
            const dragIndex = item.index
            const hoverIndex = index

            if (dragIndex === hoverIndex) {
                return
            }
            // è·å– DOM å…ƒç´ çš„ä½ç½®ä¿¡æ¯
            const hoverBoundingRect = ref.current.getBoundingClientRect()
            // è®¡ç®—æ‹–æ‹½å…ƒç´ çš„å‚ç›´ä¸­ç‚¹ä½ç½®
            const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2
            // è·å–é¼ æ ‡å½“å‰çš„ä½ç½®
            const clientOffset = monitor.getClientOffset()
            // è®¡ç®—é¼ æ ‡ä½ç½®ç›¸å¯¹äºå®¹å™¨çš„å‚ç›´åç§»é‡
            const hoverClientY = clientOffset.y - hoverBoundingRect.top

            // å¦‚æœæ‹–æ‹½å…ƒç´ åœ¨ç›®æ ‡å…ƒç´ ä¸Šæ–¹ä¸”å¤„äºå®¹å™¨çš„ä¸ŠåŠéƒ¨åˆ†ï¼Œåˆ™ä¸è¿›è¡Œæ“ä½œ
            if (dragIndex < hoverIndex && hoverClientY < hoverMiddleY) {
                return
            }
            // å¦‚æœæ‹–æ‹½å…ƒç´ åœ¨ç›®æ ‡å…ƒç´ ä¸‹æ–¹ä¸”å¤„äºå®¹å™¨çš„ä¸‹åŠéƒ¨åˆ†ï¼Œåˆ™ä¸è¿›è¡Œæ“ä½œ
            if (dragIndex > hoverIndex && hoverClientY > hoverMiddleY) {
                return
            }

            moveBox(dragIndex, hoverIndex)
            item.index = hoverIndex
        },
    })

    const [{ isDragging }, drag, preview] = useDrag({
        item: { id, index },
        type: ItemTypes.BOX,
        collect: monitor => ({
            isDragging: monitor.isDragging(),
        }),
    })

    const opacity = isDragging ? 0 : 1
    const transform = isDragging ? 'translateY(-5px)' : 'none' // æ·»åŠ å¹³æ»‘ç§»åŠ¨çš„åŠ¨ç”»æ•ˆæœ

    /** æ•´ä½“æ‹–æ‹½   */
    drag(drop(ref))

    return (
        <div
            /*     å±€éƒ¨æ‹–æ‹½çš„è§†å›¾  ref={drop(preview(ref))} */
            ref={drop(preview(ref))}
            className={styles.item}
            style={{ opacity, transform }} // åº”ç”¨åŠ¨ç”»æ•ˆæœ
        >
            {/*     å±€éƒ¨æ‹–æ‹½ ref={drag} */}
            <span ref={drag} style={{ cursor: 'move', marginRight: '8px', fontSize: '16px' }}>
                <SVGIcon xlinkHref={'#icon-icon_tuodong'} />
            </span>

            {text}
        </div>
    )
}

const DndDemo = () => {
    const [boxes, setBoxes] = useState([
        { id: 1, text: '1' },
        { id: 2, text: '2' },
        { id: 3, text: '3' },
        { id: 4, text: '4' },
    ])

    const moveBox = useCallback(
        (dragIndex, hoverIndex) => {
            const dragBox = boxes[dragIndex]
            setBoxes(prevBoxes => {
                const updatedBoxes = [...prevBoxes]
                updatedBoxes.splice(dragIndex, 1)
                updatedBoxes.splice(hoverIndex, 0, dragBox)
                return updatedBoxes
            })
        },
        [boxes],
    )

    return (
        <DndProvider backend={HTML5Backend}>
            <GlobalContent>
                <div className={styles.page}>
                    {boxes.map((box, index) => (
                        <Box
                            key={box.id}
                            id={box.id}
                            text={box.text}
                            index={index}
                            moveBox={moveBox}
                        />
                    ))}
                </div>
            </GlobalContent>
        </DndProvider>
    )
}

export default DndDemo
```

```
.page {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 1400px;
    height: 2000px;
    margin: 0 auto;
    border: 1px solid #000;
    row-gap: 30px;

    .item {
        width: 600px;
        height: 300px;
        color: #fff;
        font-size: 20px;
        background-color: rebeccapurple;
        transition: transform 0.3s ease-in-out;
        transition-property: transform, opacity;
    }
}
```

# é˜²æŠ–

```
import { useDebounceFn } from 'ahooks'

 const { run: debouncedValue } = useDebounceFn(store.searchColumns, { wait: 500 })   
  debouncedValue(v)
```

# çœç•¥å·...

```
  .contentStyle {
                max-width: 310px;
                -webkit-line-clamp: 2; // ç”¨æ¥é™åˆ¶åœ¨ä¸€ä¸ªå—å…ƒç´ æ˜¾ç¤ºçš„æ–‡æœ¬çš„è¡Œæ•°
                display: -webkit-box; // å°†å¯¹è±¡ä½œä¸ºå¼¹æ€§ä¼¸ç¼©ç›’æ¨¡å‹æ˜¾ç¤º
                -webkit-box-orient: vertical; //è®¾ç½®æˆ–æ£€æŸ¥ä¼¸ç¼©ç›’å¯¹è±¡çš„å­å…ƒç´ çš„æ’åˆ—æ–¹å¼
                text-overflow: ellipsis; // åœ¨å¤šè¡Œæ–‡æœ¬çš„æƒ…å†µä¸‹ï¼Œç”¨...éšè—è¶…å‡ºèŒƒå›´çš„æ–‡æœ¬
                word-break: break-all;
                overflow: hidden;
            }
```

# source-map .eslintrcæ ¡éªŒ

```
 devtool: 'cheap-module-source-map',                    
.umirc.tsæ–‡ä»¶


  '@typescript-eslint/no-unused-vars': 2,
 '@typescript-eslint/no-unused-vars': ['error'],
```

cascader çº§è”

```
import { Cascader, Spin } from 'antd'
// @ts-ignore
import { isEmpty } from 'lodash'
import { observer } from 'mobx-react'
import { useEffect, useState } from 'react'
import type { Options } from './interface'
import { getAuthOptionsByPid } from './api'
import { TerminalEnum } from '../../addJurisd/const'

interface AuthCascaderProps {
    id: string
    value?: any
    onChange?: (value: any[], selectedOptions: any[]) => void
}

const AuthCascader: React.FC<AuthCascaderProps> = ({ value = [], id, onChange }) => {
    const [authOptions, setAuthOptions] = useState<Options[]>([])
    const [loading, setLoading] = useState<boolean>(false)

    const filterData = async (originalData: any) => {
        setLoading(true)
        const currentOptions: Options[] = []
        let newOriginalData = originalData

        if (id) {
            newOriginalData = originalData.filter((o: any) => o.key !== Number(id))
        }

        for (let i = 0; i < newOriginalData.length; i++) {
            const item = newOriginalData[i]
            if (item.terminal !== TerminalEnum.MOBILE) {
                currentOptions.push({
                    label: `${item.title}(${item.key})`,
                    value: item.key,
                    pid: item.pid,
                    terminal: item.terminal,
                    isLeaf: false,
                })
            }
        }
        setLoading(false)
        return currentOptions
    }

    const onInitAuthOptionsList = (pid: number) => {
        return new Promise(resolve => {
            getAuthOptionsByPid(pid).then(async (res: any) => {
                const firstAuthOptions = [{ label: 'æ— ', value: 0 }, ...(await filterData(res))]
                setAuthOptions(firstAuthOptions)

                resolve(firstAuthOptions)
            })
        })
    }

    const onLoadData = async (selectedOptions: any[]) => {
        // å¼‚æ­¥åŠ è½½å­æ•°æ®
        const targetOption = selectedOptions[selectedOptions.length - 1]
        if (targetOption.value === 0) return []

        const children = (await getAuthOptionsByPid(targetOption.value)) as any
        const filterChildren = await filterData(children)
        if (!isEmpty(children)) {
            targetOption.children = filterChildren
        } else {
            targetOption.isLeaf = true
        }
        setAuthOptions(() => [...authOptions])

        return Promise.resolve(filterChildren)
    }

    useEffect(() => {
        // è¯·æ±‚ç¬¬ä¸€çº§æ•°æ®
        // @ts-ignore
        onInitAuthOptionsList(0).then(async (firstAuthOptions: Options[]) => {
            // å¦‚æœpidä¸º0çš„è¯ï¼Œè¯´æ˜æ²¡æœ‰é€‰ä¸­ä»»ä½•æƒé™
            if (value?.[0] === 0) return
            // è¯·æ±‚ç¬¬äºŒçº§æ•°æ®
            const firstIndex = firstAuthOptions.findIndex(
                (item: Options) => item.value === value?.[0],
            )

            if (firstIndex > -1) {
                const secondOptions = await onLoadData([firstAuthOptions[firstIndex]] as any)
                firstAuthOptions[firstIndex].children = secondOptions

                // è¯·æ±‚ç¬¬ä¸‰çº§æ•°æ®
                const secondIndex = secondOptions.findIndex(
                    (item: Options) => item.value === value?.[1],
                )

                if (secondIndex > -1) {
                    const thirdOptions = await onLoadData([secondOptions[secondIndex]] as any)

                    secondOptions[secondIndex].children = thirdOptions
                }

                setAuthOptions(firstAuthOptions)
            }
        })
    }, [])

    const onChangeData = (changedValue: any[], selectedOptions: any[]) => {
        if (changedValue && selectedOptions) {
            onLoadData(selectedOptions)
        }
        onChange?.(changedValue, selectedOptions)
    }

    return (
        <Spin spinning={loading}>
            <Cascader
                changeOnSelect
                value={!authOptions.length ? undefined : value}
                options={authOptions}
                placeholder="è¯·é€‰æ‹©"
                onChange={onChangeData}
                loadData={onLoadData}
                showSearch={true}
            />
        </Spin>
    )
}

export default observer(AuthCascader)
```

# å¤šé€‰æ¡†æ“ä½œ rowSelections

```
const [selectedPosition, setSelectedPosition] = useState<any>([])

const addSelectRow = (rows: any) => {
 const newList = cloneDeep(selectedPosition)
 setSelectedPosition(newList.concat(rows))
    }
const delSelectRow = (rowkey: string[]) => {
 const newList = cloneDeep(selectedPosition)
 setSelectedPosition(newList.filter((item: any) => !rowkey.includes(item.professionCode)))
    }

const getRowSelections = (store: BatchOfflinePaymentModalStore) => {
    return {
          type: 'checkbox',
          preserveSelectedRowKeys: true,
          selectedRowKeys: selectedPosition.map((item: any) => item?.professionCode),
          // onChange: (_: any, allSelectedRows: any) => {
          //     setSelectedPosition([...allSelectedRows])
          // },
          // checkStrictly: false,
          onSelect: (record: any, selected: boolean) => {
                    if (selected) {
                        addSelectRow(record)
                    } else {
                        delSelectRow([record.professionCode!])
                    }
                },
          onSelectAll: (selected: boolean, selectedRows: any[], changeRows: any[]) => {
             if (selected) {
                 addSelectRow(changeRows)
                } else {
                 delSelectRow(changeRows.map((item: any) => item.professionCode))
                  }
                },
    }
}
```

```

 const { getRowSelections, selected } = useSelections<DataTypes>({
        itemKey: 'id',
    })





import { cloneDeep } from 'lodash'
import type { TableRowSelection } from 'antd/es/table/interface'
import { message } from 'antd'
import { Key, useState } from 'react'


export interface Options<T> {
    /**  é»˜è®¤å‹¾é€‰æ•°æ®  */
    defaultSelected?: T[] | T
    /**  å”¯ä¸€æ ‡è¯†å­—æ®µ  */
    itemKey: keyof T
    /**  é€‰ä¸­ç±»å‹  */
    type?: 'radio' | 'checkbox'
    /**  è‡ªå®šä¹‰rowSelection props  */
    rowSelectionProps?: TableRowSelection<T>
    /**  æœ€å¤šå¯é€‰  */
    max?: number
}
export function useSelections<T>(props: Options<T>) {
    const { defaultSelected, itemKey, type = 'checkbox', rowSelectionProps, max } = props

    const [selected, setSelected] = useState<T[]>(
        (() => {
            if (Array.isArray(defaultSelected)) return defaultSelected
            if (defaultSelected !== undefined) return [defaultSelected]
            return []
        })(),
    )

    /**  å¢åŠ é€‰ä¸­è¡Œ  */
    const addSelectRow = (rows: T[] | T) => {
        const newList = cloneDeep(selected)

        /**  å•é€‰   */
        if (type === 'radio') {
            setSelected([rows as T])
        } else {
            // è¾¾åˆ°æœ€å¤§é€‰æ‹©æ•°é‡æ—¶ä¸å…è®¸æ·»åŠ 
            if (max && newList.length >= max) {
                message.error(`æœ€å¤šå¯é€‰${max}æ¡`)
                return
            }
            setSelected(newList.concat(rows))
        }
    }

    /** åˆ é™¤é€‰ä¸­è¡Œ  */
    const delSelectRow = (rowkey: number[]) => {
        const newList = cloneDeep(selected)
        setSelected(newList.filter((item: T) => !rowkey.includes(item[itemKey] as number)))
    }

    /**  è·å–é€‰ä¸­è¡Œ  */
    const getRowSelections = (): TableRowSelection<T> => {
        return {
            type: type,
            preserveSelectedRowKeys: true,
            selectedRowKeys: selected.map((item: T) => item[itemKey]) as Key[],
            onSelect: (record: T, selected: boolean) => {
                if (selected) {
                    addSelectRow(record)
                } else {
                    delSelectRow([record[itemKey] as number])
                }
            },
            onSelectAll: (selected: boolean, _, changeRows: T[]) => {
                if (selected) {
                    addSelectRow(changeRows)
                } else {
                    delSelectRow(changeRows.map((item: T) => item[itemKey] as number))
                }
            },
            ...rowSelectionProps,
        }
    }

    return { getRowSelections, selected }
}
```

# å±•å¼€ å˜æˆç®­å¤´ expanded

```
 /**
     * å±•å¼€ å˜æˆç®­å¤´
     * @param { expanded, onExpand, record }
     * <CaretRightOutlined />  RightOutlined
     */
    const expandIcon = ({ expanded, onExpand, record }: any) => (
        <span className={styles.expanded}>
            {record.children && record.children.length > 0 ? (
                expanded ? (
                    <RightOutlined
                        onClick={e => onExpand(record, e)}
                        className={`${styles.arrow_icon} ${styles.arrow_rotate}`}
                    />
                ) : (
                    <RightOutlined
                        onClick={e => onExpand(record, e)}
                        className={styles.arrow_icon}
                    />
                )
            ) : null}
        </span>
    )


 .expanded {
        display: inline-block;
        min-width: 14px;
        margin-right: 5px;

        .arrow_icon {
            & svg {
                transition: transform 0.3s ease;
            }
        }

        .arrow_icon:hover {
            color: var(--primary-color);
        }

        .arrow_rotate {
            & svg {
                transform: rotate(90deg);
                transition: transform 0.3s ease;
            }
        }
    }
```

# expandedRowKeys

```
    const [expandedRowKeys, setExpandedRowKeys] = useState<any[]>([]) // å±•å¼€çš„è¡Œçš„key

    expandable={{
                    expandIcon,
                    expandedRowKeys,
                }}
                onExpand={(b: boolean, r: any) => {
                    const newExp: any = b
                        ? [...expandedRowKeys, r.id]
                        : expandedRowKeys.filter(i => i !== r.id)
                    setExpandedRowKeys(newExp)
                }}
```

# InputNumber

```
 <InputNumber
                        min={0}
                        max={9999}
                        maxLength={4}
                        defaultValue={sort}
                        onBlur={e => handleSave(key, e.target.value)}
                        formatter={value => {
                            if (!value) return '0'
                            if (!/^[0-9]*$/g.test(value)) {
                                return '0'
                            }

                            return value
                        }}
                        parser={value => {
                            const parsedValue = value?.replace(/\D/g, '')

                            if (!parsedValue || parsedValue.length > 4) {
                                return '0'
                            }

                            return parsedValue
                        }}
                    />

   /**
     * æ’åºå¤±å»ç„¦ç‚¹çš„ä¿å­˜äº‹ä»¶
     */
    const handleSave = (id: number, value: string | number) => {
        const targetItem =
            store.dataSource?.find((item: { key: number }) => item?.key === Number(id)) || {}
        if (targetItem.sort === Number(value)) {
            return
        }
        let reg = /^[0-9]*$/
        if (!reg.test(value) || !value) {
            message.error('è¯·è¾“å…¥æ•°å­—')
            return
        }
        if (Number(value) > 9999) {
            message.error('æ’åºä¸èƒ½å¤§äº9999')
            store.sortOnBlur({ id, sort: '9999' }, actionRef)
            return
        }

        store.sortOnBlur({ id, sort: value }, actionRef)
    }
```

# UserMenu

```
import type { MenuProps } from 'antd';
import { ConfigProvider, Menu } from 'antd';
import React, { useEffect, useState } from 'react';
import { ReactSVG } from 'react-svg';
import './index.less';

type MenuItem = Required<MenuProps>['items'][number];

function getItem(
  label: React.ReactNode,
  key: React.Key,
  route: string,
  icon?: React.ReactNode,
  children?: MenuItem[],
): MenuItem {
  return {
    key,
    icon,
    children,
    label,
    route,
  } as MenuItem;
}

interface IUserMenuProps {
  menuList: any[];
  masterHistory?: any; // ä¸»åº”ç”¨çš„historyï¼Œç”¨æ¥è·³è½¬è·¯ç”±
}

/**  ä¸ªäººå·¥ä½œå°  */
const UserMenu: React.FC<IUserMenuProps> = ({ menuList, masterHistory }) => {
  // console.log('ğŸŠ menuList:', JSON.parse(JSON.stringify(menuList)));
  /**  å½“å‰é¡µé¢çš„url æ¥æ§åˆ¶ menuçš„é€‰ä¸­  */
  const currentUrl =
    masterHistory?.location?.pathname === '/'
      ? '/workbench'
      : masterHistory?.location?.pathname;

  // console.log('ğŸŠ currentUrl:', currentUrl);

  /**  menu items  */
  const [MenuItem, setMenuItem] = useState<MenuItem[]>([]);
  /**  é€‰ä¸­çš„key  */
  const [selectKey, SetSelectKey] = useState<string>('/workbench');
  // console.log('ğŸŠ selectKey:', selectKey);

  /**  menu æ•°æ®  */
  const items: MenuItem[] = MenuItem;
  useEffect(() => {
    let menuRes = menuList?.map((item) => {
      const {
        title = '',
        children = [],
        route = '',
        icon = '',
        key = '',
      } = item || {};

      if (children && children.length) {
        return getItem(
          title,
          route,
          key,
          '',
          children.map((child: any) => {
            return getItem(
              <span className={'child_content'}>
                <ReactSVG
                  src={child.icon || ''}
                  style={{ width: 14 }}
                  beforeInjection={(svg) => {
                    const svgPath = svg.querySelector('path');
                    svgPath?.removeAttribute('fill');
                    svg.setAttribute(
                      'style',
                      `fill:${
                        selectKey === child.route
                          ? 'currentcolor'
                          : 'rgba(0,0,0,0.45)'
                      }  ;width: 16px;height: 16px;`,
                    );
                  }}
                />
                <span className={'child_title'}>{child.title}</span>
              </span>,
              child.route,
              child.route,
            );
          }),
        );
      }

      return getItem(
        title,
        route,
        route,
        <ReactSVG
          src={icon || ''}
          style={{ height: 40 }}
          beforeInjection={(svg) => {
            const svgPath = svg.querySelector('path');
            svgPath?.removeAttribute('fill');
            svg.setAttribute(
              'style',
              `fill:${
                selectKey === route ? 'currentcolor' : 'rgba(0,0,0,0.45)'
              }  ;width: 16px;height: 16px;`,
            );
          }}
        />,
      );
    });
    setMenuItem(menuRes);
  }, [menuList]);

  /**  openKeys å…¨éƒ¨å±•å¼€  */
  const menuKeys = items.map((item) => item?.key);

  /**
   *  ç‚¹å‡»èœå•
   */
  const handleClickMenuItem = ({ key }: { key: string }) => {
    console.log('ğŸŠ key:', key);
    SetSelectKey(key);
    if (key?.includes('https') || key?.includes('http')) {
      window.location.href = key;
    } else {
      masterHistory.push(key);
    }
  };

  return (
    <ConfigProvider prefixCls="ant">
      <Menu
        defaultSelectedKeys={[currentUrl || '/workbench']}
        openKeys={menuKeys as any}
        mode="inline"
        items={items}
        className="user_menu"
        onClick={handleClickMenuItem}
      />
    </ConfigProvider>
  );
};

export default UserMenu;
```

# devtool source-map

```
devtool: process.env.NODE_ENV === 'development' ? 'eval-cheap-module-source-map' : 'source-map',
```

# è®¾ç½®æ—¶é—´é€‰æ‹©çš„èŒƒå›´ disabledTime

```
// 

 //è®¾ç½®æ—¶é—´é€‰æ‹©çš„èŒƒå›´
    const disabledTime = (date: any) => {
        const hour = dayjs().hour() // è·å–å½“å‰çš„å°æ—¶
        const min = dayjs().minute() // è·å–å½“å‰çš„åˆ†é’Ÿ
        const second = dayjs().second() // è·å–å½“å‰ç§’
        if (date?.format('YYYY-MM-DD').valueOf() === dayjs().format('YYYY-MM-DD').valueOf()) {
            if (date?.format('HH').valueOf() === dayjs().format('HH').valueOf()) {
                if (date?.format('mm').valueOf() === dayjs().format('mm').valueOf()) {
                    return {
                        disabledHours: () => range(0, 24).splice(0, hour),
                        disabledMinutes: () => range(0, 60).splice(0, min),
                        disabledSeconds: () => range(0, 60).splice(0, second),
                    }
                } else {
                    return {
                        disabledHours: () => range(0, 24).splice(0, hour),
                        disabledMinutes: () => range(0, 60).splice(0, min),
                    }
                }
            } else {
                return {
                    disabledHours: () => range(0, 24).splice(0, hour),
                }
            }
        }
    }

               <DatePicker
                  showTime={{ format: 'HH:mm:ss' }}
                  format="YYYY-MM-DD HH:mm:ss"
                  placeholder="è¯·é€‰æ‹©ä»˜æ¬¾æ—¶é—´"
                  disabledDate={cur => cur && cur < dayjs().startOf('day')}
                  disabledTime={disabledTime}
                  // bordered={false}
               />
```

```
    const disabledTimeBefore = (date: any) => {
        const now = dayjs() // å½“å‰æ—¶é—´

        if (date?.isSame(now, 'day')) {
            const hour = now.hour() // å½“å‰çš„å°æ—¶
            const min = now.minute() // å½“å‰çš„åˆ†é’Ÿ
            const second = now.second() // å½“å‰ç§’

            return {
                disabledHours: () => range(hour + 1, 24),
                disabledMinutes: (selectedHour: number) => {
                    if (selectedHour === hour) {
                        return range(min + 1, 60)
                    }
                    return []
                },
                disabledSeconds: (selectedHour: number, selectedMinute: number) => {
                    if (selectedHour === hour && selectedMinute === min) {
                        return range(second + 1, 60)
                    }
                    return []
                },
            }
        }
    }


  <DatePicker
            showTime={{ format: 'HH:mm:ss' }}
            format="YYYY-MM-DD HH:mm:ss"
            placeholder="è¯·é€‰æ‹©æ”¯ä»˜æ—¶é—´"
            disabledDate={cur => cur && cur.isAfter(dayjs(), 'day')}
            disabledTime={disabledTimeBefore}
   />
```

```
 <DatePicker
                        getPopupContainer={target => target.parentNode as any}
                        showTime={{
                            format: 'HH:mm',
                        }}
                        format="YYYY-MM-DD HH:mm"
                        placeholder="è¯·é€‰æ‹©æ—¶é—´"
                        style={{ width: '100%' }}
                        disabledTime={disabledTime as any}
                        disabledDate={(cur: Dayjs) => {
                            const { activityStart } = form.getFieldsValue()
                            // å¦‚æœæ²¡æœ‰è®¾ç½®å¼€å§‹æ—¶é—´ï¼Œåˆ™å¯è®¾ç½®ä»Šå¤©åŠä»¥åçš„æ—¶é—´
                            if (!activityStart) {
                                // @ts-ignore
                                return cur < dayjs().startOf('day')
                            }
                            // å¦‚æœè®¾ç½®äº†å¼€å§‹æ—¶é—´ï¼Œåˆ™å¯è®¾ç½®ã€å¼€å§‹æ—¶é—´ã€‘åŠä»¥åçš„æ—¶é—´
                            // @ts-ignore
                            return cur < dayjs(activityStart).startOf('day')
                        }}
                        disabled={judgeEdit(form.getFieldValue('endTime'))}
                    />

   /**  é™åˆ¶ä¿®æ”¹å­—æ®µ  */
    const judgeEdit = (time: any) => {
        dayjs.extend(isSameOrBefore)

        let today = dayjs().startOf('day')
        let flag = dayjs(time).isSameOrBefore(today, 'day') || false
        if (cannotEdit && flag) {
            return true
        } else {
            return false
        }
    }



```

# rgba è½¬ åå…­è¿›åˆ¶

```
/**  #f00 ===> rgba  */
export function hexToRGBA(hex: string) {
  const r = parseInt(hex.substring(1, 3), 16);
  const g = parseInt(hex.substring(3, 5), 16);
  const b = parseInt(hex.substring(5, 7), 16);
  const a = parseInt(hex.substring(7, 9), 16) / 255; // å°†åå…­è¿›åˆ¶é€æ˜åº¦è½¬æ¢ä¸º 0-1 èŒƒå›´å†…çš„å€¼
  return { r: r, g: g, b: b, a: a };
}

/**  rgba ===>  #f00  */
export function rgbaToHex({
  r,
  g,
  b,
  a,
}: {
  r: number;
  g: number;
  b: number;
  a: number;
}) {
  let newr = Math.round(r);
  let newg = Math.round(g);
  let newb = Math.round(b);
  let newa: string | number = Math.round(a * 255); // å°†é€æ˜åº¦ä» 0-1 è½¬æ¢ä¸º 0-255 èŒƒå›´å†…çš„å€¼
  newa = (newa | (1 << 8)).toString(16).slice(1); // è½¬æ¢ä¸ºåå…­è¿›åˆ¶å¹¶ç¡®ä¿å§‹ç»ˆæ˜¯ä¸¤ä½

  return (
    '#' +
    ((1 << 24) + (newr << 16) + (newg << 8) + newb).toString(16).slice(1) +
    newa
  );
}
```

# è§£å†³å¯Œæ–‡æœ¬å›¾ç‰‡ä¸å±…ä¸­é—®é¢˜

```
        /**  è§£å†³å¯Œæ–‡æœ¬å›¾ç‰‡ä¸å±…ä¸­é—®é¢˜  */
        let parser = new DOMParser()
        let doc = parser.parseFromString(detail as string, 'text/html')

        // æ‰¾å‡ºæ‰€æœ‰åŒ…å« img æ ‡ç­¾çš„çˆ¶çº§ p å…ƒç´ 
        let imgParents = doc.querySelectorAll('p > img')

        // éå†æ¯ä¸ª img çš„çˆ¶çº§ p å…ƒç´ 
        imgParents.forEach(parent => {
            // @ts-ignore è·å–çˆ¶çº§ p å…ƒç´ çš„ text-align å±æ€§å€¼
            let textAlign = parent?.parentNode?.style.textAlign

            const alignmentClassMap: Record<string, string> = {
                left: 'img_left',
                start: 'img_start',
                center: 'img_center',
                right: 'img_right',
                justify: 'img_justify',
                // å¦‚æœæœ‰å…¶ä»–å¯¹åº”å…³ç³»ï¼Œå¯ä»¥ç»§ç»­æ·»åŠ 
            }
            // @ts-ignore
            parent?.parentNode?.classList.add(alignmentClassMap[textAlign])
        })
        let modifiedHtmlStr = doc.documentElement.innerHTML
```

# Cascader

```
interface RegionSelectorProps {
    holder?: string
    value?: any
    onChange?: (e: any) => void
}
const RegionSelector: React.FC<RegionSelectorProps> = ({ holder, value = [], onChange }) => {
    const [options, setOptions] = useState<Option[]>([])
    const [isInit, setIsInit] = useState(true)

    const getAreaData = async (parentCode: string | number) => {
        const data = (await Http(
            api.getAreaData,
            'get',
            { parentCode: parentCode },
            { repeatFilter: false },
        )) as unknown as []
        let list: Option[] = []
        data.forEach((item: any) => {
            list.push({
                label: item.name,
                value: item.code,
                isLeaf: ![0, 1, 2].includes(item.level), // 0 å›½å®¶å±‚çº§ 1 çœä»½å±‚çº§ 2 å¸‚åŒºå±‚çº§ 3 åœ°åŒºå±‚çº§
            })
        })
        return list
    }

    const handleAreaList = async (value: string[]) => {
        const list = await getAreaData('-1') // é»˜è®¤è¯·æ±‚å›½å®¶å±‚çº§æ•°æ®
        // å¦‚æœvalueçš„é•¿åº¦æ˜¯3(å›½ã€çœã€å¸‚)ï¼Œåªéœ€è¦è¯·æ±‚ä¸¤æ¬¡ åˆ†åˆ«è·å–province, cityå±‚çº§æ•°æ®
        // å¦‚æœvalueçš„é•¿åº¦æ˜¯2(å›½ã€çœ)ï¼Œåªéœ€è¦è¯·æ±‚ä¸€æ¬¡ è·å–provinceå±‚çº§æ•°æ®
        // å¦‚æœvalueçš„é•¿åº¦æ˜¯1(å›½)ï¼Œä¸éœ€è¦è¯·æ±‚(åˆå§‹åŒ–å·²ç»è¯·æ±‚è¿‡å›½å®¶å±‚çº§æ•°æ®äº†)
        const [country, province, city] = value.slice()
        let targetProvince, targetCountry, targetCity
        let provinces, cities
        if (value.length >= 2) {
            provinces = await getAreaData(country)
            // å°†çœçº§æ”¾åˆ°å¯¹åº”å›½çº§childrené‡Œé¢
            targetCountry = list.find(_country => Number(_country.value) === Number(country)) ?? {}
            targetCountry.children = provinces
        }

        if (value.length >= 3) {
            cities = await getAreaData(province)
            // å°†åŸå¸‚æ”¾åˆ°å¯¹åº”çš„çœçº§childrené‡Œé¢
            targetProvince =
                provinces.find(_province => Number(_province.value) === Number(province)) ?? {}
            targetProvince.children = cities
        }
        // å°†åŒºçº§æ”¾åˆ°å¸‚çº§ä¸‹é¢
        if (value.length >= 4) {
            const areas = await getAreaData(city)
            targetCity = cities.find(_city => Number(_city.value) === Number(city)) ?? {}
            targetCity.children = areas
        }
        setOptions(list)
    }
    const getAreaOptions = async (selectedOptions: Option[]) => {
        const targetOption = selectedOptions[selectedOptions.length - 1]
        targetOption.loading = true
        const currentList = await getAreaData(targetOption.value)
        targetOption.loading = false
        targetOption.children = currentList
        setOptions([...options])
    }

    useEffect(() => {
        if (!value?.length) {
            handleAreaList(value)
        }

        // å›æ˜¾æ•°æ®
        if (value?.[0] !== undefined && isInit) {
            // é¿å…valueç©ºæ•°ç»„é‡å¤æ¸²æŸ“
            setIsInit(false)
            handleAreaList(value)
        }
    }, [value?.[0]])

    return (
        <Cascader
            value={value}
            options={options}
            loadData={getAreaOptions}
            placeholder={holder}
            changeOnSelect
            onChange={onChange}
        />
    )
}
```

# åœ°å›¾

```
import React, { useEffect, useState } from 'react'
import { Modal } from 'antd'
import wrapper from '@/utils/wrapper'
import styles from './index.module.less'
import AMapLoader from '@amap/amap-jsapi-loader'
import { Input, message } from 'antd'
const { Search } = Input

interface AMapModalProps {
    visible: boolean
    closeDialog: () => void
    value?: string
    submit?: (value?: string) => void
}
/**  åœ°å›¾å®ä¾‹  */
let map: any = null
/**  æ ‡è®°  */
let marker: any = null
/**  æ¯”ä¾‹å°º  */
let scale: any = null
/**  å·¥å…·æ¡  */
let toolBar: any = null
/**  æœç´¢  */
let placeSearch: any = null
let auto: any = null
/**  ç‚¹å‡»äº‹ä»¶  */
let geocoder: any = null
//è¾“å…¥æç¤º
let autoOptions = {
    input: 'tipinput',
}

const AMapModal: React.FC<AMapModalProps> = props => {
    const { visible, closeDialog, value, submit } = props
    const [searchValue, setSearchValue] = useState('')

    const onSearch = (v: string) => {
        setSearchValue(v) // æ›´æ–°æœç´¢æ¡†è¾“å…¥çš„å€¼
        placeSearch?.search(searchValue)
    }
    /**  é€‰æ‹©äº‹ä»¶  */
    function select(e: any) {
        placeSearch.setCity(e?.poi?.adcode)
        placeSearch.search(e?.poi?.name) //å…³é”®å­—æŸ¥è¯¢æŸ¥è¯¢
        marker.setPosition(e?.poi?.location)
    }
    /**  ç‚¹å‡»äº‹ä»¶  */
    function showInfoClick(e: any) {
        marker.setPosition(e?.lnglat)
        // é€†åœ°ç†ç¼–ç è·å–åœ°ç‚¹ä¿¡æ¯
        geocoder?.getAddress(e?.lnglat, function (status: any, result: any) {
            if (status === 'complete' && result?.info === 'OK') {
                if (result.regeocode && result.regeocode.formattedAddress) {
                    let address = result?.regeocode?.formattedAddress
                    setSearchValue(address)
                }
            } else {
                message.error('é€†åœ°ç†ç¼–ç å¤±è´¥')
            }
        })
    }

    useEffect(() => {
        if (value) {
            onSearch(value)
        }
    }, [value])

    useEffect(() => {
        // @ts-ignore
        window._AMapSecurityConfig = {
            securityJsCode: '75204b4ecec46a97e9906a83b0cc8b5d',
        }
        AMapLoader.load({
            key: '1ae45beffb6052b82267651855e0bcc7', // ç”³è¯·å¥½çš„Webç«¯å¼€å‘è€…Keyï¼Œé¦–æ¬¡è°ƒç”¨ load æ—¶å¿…å¡«
            version: '2.0', // æŒ‡å®šè¦åŠ è½½çš„ JSAPI çš„ç‰ˆæœ¬ï¼Œç¼ºçœæ—¶é»˜è®¤ä¸º 1.4.15
            plugins: [
                'AMap.Scale', //æ¯”ä¾‹å°º
                'AMap.ToolBar', // å·¥å…·æ¡
                'marker', //æ ‡è®°
                'AMap.Geolocation', // å¤§è‡´å®šä½
                'AMap.PlaceSearch', //æœç´¢
                'AMap.AutoComplete', //æœç´¢
                'AMap.Geocoder', // é€†åœ°ç†ç¼–ç ï¼ˆåæ ‡ -> åœ°å€ï¼‰
            ], //éœ€è¦ä½¿ç”¨çš„çš„æ’ä»¶åˆ—è¡¨ï¼Œ
        })
            .then(AMap => {
                map = new AMap.Map('mapContainer', {
                    zoom: 15, //åˆå§‹åŒ–åœ°å›¾å±‚çº§
                    resizeEnable: true,
                })
                // æ ‡è®°
                marker = new AMap.Marker({})
                /**  æ¯”ä¾‹å°º  */
                scale = new AMap.Scale({
                    visible: true,
                })
                /**  å·¥å…·æ¡  */
                toolBar = new AMap.ToolBar({
                    visible: true,
                    position: {
                        top: '110px',
                        right: '40px',
                    },
                })
                auto = new AMap.AutoComplete(autoOptions)
                placeSearch = new AMap.PlaceSearch({
                    map: map,
                })
                placeSearch?.search(value)
                AMap.plugin(['AMap.PlaceSearch', 'AMap.AutoComplete'], function () {
                    auto.on('select', select) //æ³¨å†Œç›‘å¬ï¼Œå½“é€‰ä¸­æŸæ¡è®°å½•æ—¶ä¼šè§¦å‘
                })
                geocoder = new AMap.Geocoder({
                    city: '010', //åŸå¸‚è®¾ä¸ºåŒ—äº¬ï¼Œé»˜è®¤ï¼šâ€œå…¨å›½â€
                    radius: 1000, //èŒƒå›´ï¼Œé»˜è®¤ï¼š500
                })

                map.add(marker)
                map.addControl(scale)
                map.addControl(toolBar)
                map.on('click', showInfoClick)
            })
            .catch(e => {
                console.log(e)
            })
        return () => {
            map?.destroy()
        }
    }, [])

    return (
        <Modal
            open={visible}
            centered
            width={1200}
            title={'æ·»åŠ æ´»åŠ¨åœ°ç‚¹'}
            onCancel={closeDialog}
            onOk={() => {
                submit?.(searchValue)
                closeDialog()
            }}
        >
            <div className={styles.page_modal}>
                <div id="myPageTop" className={styles.page_modal_top}>
                    <Search
                        id="tipinput"
                        placeholder="è¾“å…¥è€ƒå‹¤åœ°ç‚¹"
                        enterButton="æœç´¢"
                        size="large"
                        onSearch={onSearch}
                        value={searchValue}
                        onChange={(e: any) => {
                            setSearchValue(e.target.value)
                        }}
                    />
                </div>
                <div id="mapContainer" style={{ width: '100%', height: '400px' }} />
            </div>
        </Modal>
    )
}

export default wrapper(AMapModal)
```

```
import React, { useEffect, useRef, useState } from 'react'
import { Modal, Select } from 'antd'
import wrapper from '@/utils/wrapper'
import styles from './index.module.less'
import _ from 'lodash'

interface AMapModalProps {
    visible: boolean
    closeDialog: () => void
    value?: any
    submit?: (value?: object) => void
}

const AMapModal: React.FC<AMapModalProps> = props => {
    const { visible, closeDialog, value, submit } = props
    const mapData = useRef<null | object>(null)
    const mapRef = useRef<any>(null)
    const markerLayer = useRef<any>(null)
    const [suggestions, setSuggestions] = useState([])

    /**  æœç´¢  */
    const handleSearchByKeyword = _.throttle((keyword: string) => {
        // ä½¿ç”¨è€…åœ¨æœç´¢æ¡†ä¸­è¾“å…¥æ–‡å­—æ—¶è§¦å‘
        if (keyword) {
            // @ts-ignore æ–°å»ºä¸€ä¸ªå…³é”®å­—è¾“å…¥æç¤ºç±»
            const suggest = new window.TMap.service.Suggestion({
                pageSize: 10,
            })
            suggest
                .getSuggestions({ keyword: keyword, location: mapRef.current?.getCenter() })
                .then((result: any) => {
                    const list = result?.data.map((item: any) => ({
                        label: item.title,
                        value: `${item.location.lng},${item.location.lat}`,
                    }))
                    setSuggestions(list)
                })
                .catch((error: any) => {
                    console.error(error)
                })
        }
    }, 500)

    /**  è·å–åœ°å€ä¿¡æ¯  // å°†ç»™å®šçš„åæ ‡ä½ç½®è½¬æ¢ä¸ºåœ°å€ */
    const getLocationInfo = async (values: any) => {
        // @ts-ignore
        const location = new window.TMap.LatLng(values.lat, values.lng)
        // @ts-ignore
        const geocoder = new window.TMap.service.Geocoder()
        const { result } = await geocoder.getAddress({ location }) // å°†ç»™å®šçš„åæ ‡ä½ç½®è½¬æ¢ä¸ºåœ°å€
        console.log('ğŸŠ result:', result)
        const regex = /^156/

        const params = {
            addressInfo: result.address,
            city: result.ad_info.city,
            cityCode: result.ad_info.city_code.replace(regex, ''),
            companyAddress: result.address,
            latitude: values.lat,
            longitude: values.lng,
            province: result.ad_info.province,
            provinceCode: result.ad_info.adcode.slice(0, 2) + '0000',
            region: result.ad_info.district,
            regionCode: result.ad_info.adcode,
            // label: values?.title || result.address,
            label: result?.formatted_addresses?.standard_address || values?.title,

            value: values.lng + ',' + values.lat,
        }

        mapData.current = params
    }

    /**   å°†é€‰ä¸­çš„åœ°å€æ”¾åœ¨åœ°å›¾ä¸­å¿ƒ  æ·»åŠ åœ°å›¾æ ‡è®°ç‚¹markerLayer  */
    const handleGetSuggestions = (item: any) => {
        if (!item) return
        const lngLat = item?.value.split(',')
        // @ts-ignore
        const centerLngLat = new window.TMap.LatLng(lngLat[1], lngLat[0])
        mapRef.current?.setCenter(centerLngLat)
        markerLayer.current?.updateGeometries([{ id: '1', position: centerLngLat }])
        const [lng, lat] = item?.value.split(',') || []
        getLocationInfo({ lng, lat, title: item?.label })
    }
    /**  åœ°å›¾ç‚¹å‡»äº‹ä»¶  */
    const handleMapClick = (evt: any) => {
        const { latLng } = evt
        // @ts-ignore
        const centerLngLat = new window.TMap.LatLng(latLng?.lat, latLng?.lng)
        mapRef.current?.setCenter(centerLngLat)
        markerLayer.current?.updateGeometries([{ id: '1', position: centerLngLat }])
        getLocationInfo({ lng: latLng?.lng, lat: latLng?.lat })
    }

    const initMap = () => {
        // @ts-ignore åˆå§‹åŒ–åœ°å›¾
        const map = new window.TMap.Map('container', {
            zoom: 15, // è®¾ç½®é»˜è®¤åœ°å›¾æ¯”ä¾‹
            // @ts-ignore
            mapZoomType: window.TMap.constants.MAP_ZOOM_TYPE.CENTER, // åœ°å›¾ç¼©æ”¾ç„¦ç‚¹æ§åˆ¶
        })
        mapRef.current = map
        // @ts-ignore
        markerLayer.current = new window.TMap.MultiMarker({
            map: map, //æŒ‡å®šåœ°å›¾å®¹å™¨
        })

        // ç»‘å®šåœ°å›¾ç‚¹å‡»äº‹ä»¶
        mapRef.current.on('click', handleMapClick)
    }

    useEffect(() => {
        setTimeout(() => {
            initMap()
        }, 50)
    }, [])

    useEffect(() => {
        setTimeout(() => {
            if (value) {
                handleGetSuggestions(value)
            }
        }, 100)
    }, [value])

    return (
        <Modal
            open={visible}
            centered
            width={1200}
            title={'æ·»åŠ æ´»åŠ¨åœ°ç‚¹'}
            onCancel={closeDialog}
            onOk={() => {
                console.log('ğŸŠ mapData:', mapData)
                submit?.(mapData)
                closeDialog()
            }}
        >
            <div className={styles.page_modal}>
                <div id="myPageTop" className={styles.page_modal_top}>
                    <Select
                        style={{ width: '100%' }}
                        showSearch
                        placeholder="è¯·è¾“å…¥åœ°å€"
                        defaultActiveFirstOption={false}
                        showArrow={false}
                        filterOption={false}
                        onSearch={handleSearchByKeyword}
                        onChange={handleGetSuggestions}
                        notFoundContent={null}
                        options={suggestions}
                        labelInValue
                    />
                </div>
                <div id="container" style={{ width: '100%', height: '400px' }} />
            </div>
        </Modal>
    )
}

export default wrapper(AMapModal)
```

# æ·»åŠ url params

```

/**  æ·»åŠ url  */
export const addFormParams = (key: string, e: number) => {
    let currentUrl = new URL(window.location.href)

    if (currentUrl.searchParams.has(key)) {
        currentUrl.searchParams.delete(key)
    }

    currentUrl.searchParams.append(key, e.toString())
    window.history.replaceState({}, '', currentUrl)
}
```

# å½•éŸ³ è½¬æ–‡å­—

```
  /**  å¼€å§‹å½•éŸ³  */
    const startRecording = () => {
        recorder.current = window.Recorder({
            onProcess: function (
                buffers: any,
                _powerLevel: any,
                _bufferDuration: any,
                bufferSampleRate: any,
                newBufferIdx: any,
            ) {
                // å®æ—¶æ¨å…¥asrå¤„ç†ã€‚asr.inputéšæ—¶éƒ½å¯ä»¥è°ƒç”¨ï¼Œå°±ç®—asrå¹¶æœªstartï¼Œä¼šç¼“å†²åˆ°asr.startå®Œæˆç„¶åå°†å·²inputçš„æ•°æ®è¿›è¡Œè¯†åˆ«
                /** ä¸è¯´è¯çš„æ—¶å€™ä¼šè¯†åˆ«å‡ºä¸€ä¸ªå­—ï¼Œæ‰€ä»¥åŠ ä¸ªä¼˜åŒ– */
                if (asrRef.current && (_powerLevel > 3 || asrTextRef?.current)) {
                    asrRef.current.input(buffers, bufferSampleRate, newBufferIdx)
                } else {
                    asrRef.current.input([new Int16Array(9)], bufferSampleRate, 0)
                }
            },
        })
        asrRef.current = window.Recorder.ASR_Aliyun_Short({
            tokenApi: '/ai/front/voice/get_key',
            apiRequest: (url: any, _args: any, success: any) => {
                http(url, 'GET', {}).then((data: any) => {
                    success({ appkey: data.appKey, token: data.token })
                })
            },
            asrProcess: (text: string, nextDuration: any, abortMsg: string) => {
                if (abortMsg) {
                    //è¯­éŸ³è¯†åˆ«ä¸­é€”å‡ºé”™ï¼Œå•ä¸ªæ–‡ä»¶è¯†åˆ«æ— éœ€ä»»ä½•å¤„ç†ï¼Œä¼šè‡ªåŠ¨å›è°ƒç»“æœ
                    return false
                }
                asrTextRef.current = text
                console.log('[asrProcesså›è°ƒ]å½“å‰è¯†åˆ«ç»“æœï¼š' + text, nextDuration)
                if (value) {
                    if (max && value?.length >= max) {
                        Toast.show(`æœ€å¤šå¯å¡«${max}ä¸ªå­—`)
                        asrRef.current?.stop()
                        recorder.current?.close()
                        return
                    }
                    setValue(value + text)
                } else {
                    if (max && text?.length >= max) {
                        setValue(text.slice(0, max))
                        Toast.show(`æœ€å¤šå¯å¡«${max}ä¸ªå­—`)
                        asrRef.current?.stop()
                        recorder.current?.close()
                        return
                    }
                    setValue(text)
                }
                const textArea_id: any = document.getElementById('textArea_id')
                textArea_id.scrollTop = textArea_id.scrollHeight

                return true
            },
            log: (msg: any) => {
                console.log(msg)
            },
            //é«˜çº§é€‰é¡¹
            fileSpeed: 1,
        })

        recorder.current.open(
            () => {
                if (store.isLongPress) {
                    asrRef.current.start(
                        function () {
                            //å¼€å§‹å½•éŸ³
                            recorder.current.start()
                        },
                        function (errMsg: any) {
                            console.log('ğŸŠ errMsg:', errMsg)
                        },
                    )
                } else {
                    asrRef.current.stop()
                    recorder.current?.close()
                }
            },
            (msg: string, isUserNotAllowed: any) => {
                store.upDatePress(false)
                Toast.show(isUserNotAllowed ? 'ç”¨æˆ·æ‹’ç»äº†æˆæƒ' : msg)
            },
        )
    }

    /**  æŒ‰ä¸‹  */
    const handleMouseDown = () => {
        store.upDatePress(true)
        timeoutRef.current = setTimeout(() => {
            // Toast.show('å¼€å§‹å½•éŸ³')
            navigator.vibrate =
                navigator?.vibrate ||
                navigator?.webkitVibrate ||
                navigator?.mozVibrate ||
                navigator?.msVibrate
            //æ”¯æŒè®¾å¤‡éœ‡åŠ¨
            if (navigator.vibrate) {
                navigator.vibrate(200)
            }
            startRecording()
        }, 500)
    }

    /**  æ¾å¼€  */
    const handleMouseUp = () => {
        clearTimeout(timeoutRef.current)
        // Toast.show('ç»“æŸå½•éŸ³')
        if (store.isLongPress) {
            store.upDatePress(false)

            recorder.current?.stop(() => {
                /** æš‚åœars */
                asrRef.current.stop((text: string) => {
                    console.log('text:', text)
                })
                asrRef.current.stop()
                recorder.current?.close()
            })
        } else {
            Toast.show('è¯·å…ˆè¯´ç‚¹ä»€ä¹ˆ')
        }
    }
```

# ScrollListView æˆ‘è¿˜æ˜¯æœ‰åº•çº¿çš„

```
@import url('~@/styles/mixin.less');
:global {
    .adm-infinite-scroll {
        margin-top: 0 !important;
        padding: 0;
    }
}
.loadMore {
    width: 702px;
    height: 88px;
    color: #999;
    font-size: 28px;
    line-height: 88px;
    text-align: center;
    span {
        margin-right: 8px;
    }
}
.endText {
    gap: 24px;
    width: 702px;
    height: 88px;
    margin: 0 auto;
    color: #999;
    font-size: 28px;
    .flex(center,center);
    > div {
        width: 80px;
        height: 2px;
        background: #ddd;
    }
}
```

```
/* eslint-disable react-hooks/exhaustive-deps */
import { useCallback, useEffect, useState, useRef } from 'react'
import { InfiniteScroll } from 'antd-mobile'
import type { Props } from './interface'
import styles from './index.module.less'
import IconFont from '@/components/Common/IconFont'
import { useDeepCompareEffect } from 'ahooks'
let page = 0
export const transformData = (list: any, flag: boolean) => {
    if (flag) {
        return list.map((item: any) => {
            return {
                ...item,
                selected: false,
            }
        })
    }
    return list
}

export default function ScrollListView<T extends object, P>(props: Props<T, P>) {
    const { render, requestApi, params, getInfo, onDataChange } = props
    const [dataSource, setDataSource] = useState<T[]>([])
    const [total, setTotal] = useState<number>(0)
    const [loading, setLoading] = useState(true)
    const prevTapRef = useRef<any>(null) // ç”¨äºå­˜å‚¨ä¸Šä¸€æ¬¡çš„tapä¿¡æ¯

    useDeepCompareEffect(() => {
        onDataChange?.(dataSource)
    }, [dataSource])

    const request = useCallback(
        async (isReload?: boolean) => {
            page = page + 1
            const requestParams = {
                per_page: 10,
                page,
                ...(params || ({} as P)),
            }
            const { data } = await requestApi(requestParams)
            // @ts-ignore æ¯”è¾ƒtapçš„å˜åŒ–ï¼Œåªåœ¨tapæ›´æ–°æ—¶è°ƒç”¨getInfo
            if (JSON.stringify(data?.tap) !== JSON.stringify(prevTapRef.current)) {
                // @ts-ignore
                getInfo?.(state => {
                    // @ts-ignore
                    return isReload ? data?.tap : { ...state, ...data?.tap }
                })
                // @ts-ignore
                prevTapRef.current = data?.tap // æ›´æ–°prevTapRef
            }

            setLoading(false)
            setDataSource(state => {
                return isReload ? data.list : [...state, ...data.list]
            })

            page === 1 && setTotal(data.total)
        },
        [params],
    )
    const reload = () => {
        page = 0
        request(true)
    }

    useEffect(() => {
        request(true)
        return () => {
            page = 0
        }
    }, [request])

    const sliceArr = (data: T[]): { leftList: T[]; rightList: T[] } => {
        const leftList: T[] = []
        const rightList: T[] = []
        let isLeft = true
        data.forEach((item, index) => {
            if (isLeft && index !== data.length - 1) {
                leftList.push(item)
                isLeft = !isLeft
            } else {
                rightList.push(item)
                isLeft = !isLeft
            }
        })
        return { leftList, rightList }
    }

    return (
        <>
            {render(dataSource, reload, sliceArr(dataSource), loading)}
            <InfiniteScroll loadMore={() => request()} hasMore={dataSource.length < total}>
                {hasMore => {
                    if (hasMore) {
                        return (
                            <div className={styles.loadMore}>
                                <span>
                                    {' '}
                                    <IconFont type="icon-icon_jiazai" />
                                </span>
                                æ­£åœ¨åŠªåŠ›åŠ è½½ä¸­...
                            </div>
                        )
                    }
                    if (!dataSource.length) return null
                    return (
                        <div className={styles.endText}>
                            <div />
                            <span>æˆ‘è¿˜æ˜¯æœ‰åº•çº¿çš„</span>
                            <div />
                        </div>
                    )
                }}
            </InfiniteScroll>
        </>
    )
}
```

```
import type { ReactElement } from 'react'
import type { HttpResponsePending } from '@/server/interface'
import type { PaginationType } from '@/types'

/**å“åº”ç±»å‹ */
export interface RequestResult<T> {
    list: T[]
    total: number
}

/**
 * @T è¿”å›listæ•°æ®ç±»å‹
 * @P é™¤äº†åˆ†é¡µä»¥å¤–å…¶ä»–å‚æ•°
 */
export interface Props<T, P> {
    /** å‚æ•°ä¸ºdataæ•°æ®ï¼Œrenderéœ€è¦è¿”å›JSXå…ƒç´  */
    render: (
        data: T[],
        reload: () => void,
        sliceArr: { leftList: T[]; rightList: T[] },
        /** åŠ è½½ä¸­ */
        loading?: boolean,
    ) => ReactElement
    /** é™¤åˆ†é¡µå¤– è¯·æ±‚æºå¸¦çš„å…¶ä»–å‚æ•° */
    params?: P
    /** è¯·æ±‚æ¥å£ çº¦æŸä¸ºPromise */
    requestApi: (v: P & PaginationType) => HttpResponsePending<{ list: T[]; total: number }>
    /**  è·å–Info  */
    getInfo?: (v: any) => void
}
```

```
                  <ScrollListView<ProductType, ProductListReq>
                        render={renderList}
                        requestApi={getProductList}
                        params={params}
                    />
```